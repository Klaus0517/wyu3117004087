三天的作业包括代码都在这个文件里，辛苦老师！


9.14号作业：
1 什么是类，对象，他们的关系是怎么样的。
类是模板，是一种状态或者行为，是抽象的事物；对象是比较形象的事物，或是一个实例，

2 构造方法有几种？请简单说一下
构造方法有两种，分为有参数构造和无参数构造，有参数构造需定义字符型

3 数据类型有几种？以及每种的默认值是多少?请简单说一下
byte short int long float double char 默认值都为0 还有引用类型

4 强制类型转换需要注意什么？
转换的数据类型必须是兼容的

5 变量有几种？他们的作用范围是什么？
类变量独立于方法之外的变量，用static修饰，实例变量独立于方法之外的变量，局部变量类的方法中的变量

6 访问修饰符有几种？他们的作用范围是什么？
四种，default在同一个包内可见，不使用任何修饰符。
private在同一个类内可见，不能修饰外部类
public对所有类可见
protected对同一个包内的类和所有子类可见

7 static 修饰的类，变量，方法和普通对象的类，变量，方法有什么区别
一旦类被使用到，bai首先加载的是它du的静态变量，然后是静态初始化块，静态方法。

8 a++ 和 ++a的区别是什么
a++是先输出再自加，++a是先自增再输出

9 运算符优先级最高的是哪个？
后缀[],{},()

10 循环语句有几种？请简单列一下
三种，while，do...while，for

11 if条件语句可以有多个else吗？
至多一个

12 continue 和 break 在循环语句中的区别？
continue是跳到下一条命令，break是终止当前命令

13 StringBuilder 与StringBuffer的区别？
Builder速度快，Buffer要求线程安全

14 final, finally的区别？
finally块通常放在try、catch的后面，有时可以直接放在try 的后面，但有时会不能放。
被final修饰的方法是一个最终方法，不能被重写，当重写的时候会提示其父类的方法是被final修饰的，所以不能够重写。但是被final修饰的方法，其子类是可以重载的

15 jvm由哪几部分组成
字节码指令集，一组寄存器，一个栈，一个垃圾回收堆，一个储存方法域

16 用java语言描述你周围常见的事物？例如一只猫，一条狗，一座大楼，空调，手机，等等。
大楼是类，猫和狗是对象，空调和手机是方法

17 自己手动画一下jvm的内存分部图。
方法区，java堆，java栈，本地方法栈




9.15号作业：
1）定义一个交通工具Vehicle类，类中包含：
属性：速度(speed)、体积(size)
方法：加速speedUp(), 减速speedDown()，方法中控制台输出字符串“加速”/“减速”即可
2）编写测试类Main, main方法中实例化Vehicle对象，为所有属性赋值并输出，最后调用加速，减速方法。

package Vehicle;

public class Vehicle {
	public int speed;
	public int size;
	
	public void speedUp() {
		System.out.println("加速");
	}
	public void speedDown() {
		System.out.println("减速");
	}
}

public class TestVehicle {

	public static void main(String[] args) {
		Vehicle a = new Vehicle();
		a.speedUp();
		a.speedDown();

	}

}

编写Java程序用于显示人的姓名和年龄。 
1）定义一个Person类，该类中应该有两个私有属性，姓名(name)和年龄(age)，以及性别(gender)。
2）定义不同参数列表的构造方法并初始化，控制台打印输出。
4)编写测试类Main,在main方法中根据不同重载的构造方法，分别创建Person类的实例

public class Person {
	private String name;
	private int age;
	public String gender;

	public Person(String name, int age, String gender) {
		this.name = name;
		this.age = age;
		this.gender = gender;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public String getGender() {
		return gender;
	}

	public void setGender(String gender) {
		this.gender = gender;
	}

	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + ", gender=" + gender + "]";
	}
}
public class TestPerson {

	public static void main(String[] args) {
		TestPerson test = new TestPerson();
		Person a = new Person("小明", 18, "girl");
		System.out.println(a);
	}

}

9.16号作业
使用文件流复制myfile.txt文件为myfile_cp.txt
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyFile {
	public static void copyFile(String src, String dest) throws IOException {
		FileInputStream in = new FileInputStream(src);
		File file = new File(dest);
		if (!file.exists())
			file.createNewFile();
		FileOutputStream out = new FileOutputStream(file);
		int c;
		byte buffer[] = new byte[1024];
		while ((c = in.read(buffer)) != -1) {
			for (int i = 0; i < c; i++)
				out.write(buffer[i]);
		}
		in.close();
		out.close();
	}

	public static void main(String[] args) throws IOException {
		String fileSrc = "F:/917/myfile.txt";
		String fileDes = "F:/917/myfile_cp.txt";
		copyFile(fileSrc, fileDes);// 调用文件复制方法
		System.out.println("复制成功");
	}
}


使用缓冲流复制myfile.txt文件为myfile_cp2.txt
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;

public class IOCopyFlie {

	public static void main(String[] args) throws IOException {
		String fileSrc = "F:/917/myfile.txt";
		String fileDes = "F:/917/myfile_cp2.txt";
		FileInputStream fi = null;
		FileOutputStream fo = null;
		FileChannel in = null;
		FileChannel out = null;
		try {
			fi = new FileInputStream(fileSrc);
			fo = new FileOutputStream(fileDes);
			in = fi.getChannel();// 得到对应的文件通道
			out = fo.getChannel();// 得到对应的文件通道
			in.transferTo(0, in.size(), out);// 连接两个通道，且从in通道读取，然后写入out通道
		} catch (IOException e) {

			e.printStackTrace();
		} finally {
			try {
				fi.close();
				in.close();
				fo.close();
				out.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		System.out.println("复制成功");
	}
}

